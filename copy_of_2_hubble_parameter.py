# -*- coding: utf-8 -*-
"""Copy of 2_hubble_parameter.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1oJGXmt_GcDooPC4lt3B9OWvKaOj40hq1

# üî≠ Assignment: Measuring Cosmological Parameters Using Type Ia Supernovae

In this assignment, you'll analyze observational data from the Pantheon+SH0ES dataset of Type Ia supernovae to measure the Hubble constant $H_0$ and estimate the age of the universe. You will:

- Plot the Hubble diagram (distance modulus vs. redshift)
- Fit a cosmological model to derive $H_0$ and $\Omega_m$
- Estimate the age of the universe
- Analyze residuals to assess the model
- Explore the effect of fixing $\Omega_m$
- Compare low-z and high-z results

Let's get started!

## üì¶ Getting Started: Setup and Libraries

Before we dive into the analysis, we need to import the necessary Python libraries:

- `numpy`, `pandas` ‚Äî for numerical operations and data handling
- `matplotlib` ‚Äî for plotting graphs
- `scipy.optimize.curve_fit` and `scipy.integrate.quad` ‚Äî for fitting cosmological models and integrating equations
- `astropy.constants` and `astropy.units` ‚Äî for physical constants and unit conversions

Make sure these libraries are installed in your environment. If not, you can install them using:

```bash
pip install numpy pandas matplotlib scipy astropy
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from scipy.optimize import curve_fit
from scipy.integrate import quad
from astropy.constants import c
from astropy import units as u

"""## üìÇ Load the Pantheon+SH0ES Dataset

We now load the observational supernova data from the Pantheon+SH0ES sample. This dataset includes calibrated distance moduli $\mu$, redshifts corrected for various effects, and uncertainties.

### Instructions:
- Make sure the data file is downloaded from [Pantheon dataset](https://github.com/PantheonPlusSH0ES/DataRelease/blob/main/Pantheon%2B_Data/4_DISTANCES_AND_COVAR/Pantheon%2BSH0ES.dat) and available locally.
- We use `delim_whitespace=True` because the file is space-delimited rather than comma-separated.
- Commented rows (starting with `#`) are automatically skipped.

We will extract:
- `zHD`: Hubble diagram redshift
- `MU_SH0ES`: Distance modulus using SH0ES calibration
- `MU_SH0ES_ERR_DIAG`: Associated uncertainty

More detailed column names and the meanings can be referred here:

![image.png](attachment:image.png)
"""

# File path ‚Äî it matches exactly what you uploaded
file_path = "/Pantheon+SH0ES (1).dat"

# Load the data
data = pd.read_csv(file_path, delim_whitespace=True, comment="#")

# See the structure of the data
print(data.head())

"""## üßæ Preview Dataset Columns

Before diving into the analysis, let‚Äôs take a quick look at the column names in the dataset. This helps us verify the data loaded correctly and identify the relevant columns we‚Äôll use for cosmological modeling.

"""

# Show all column names in the dataset
print(data.columns)

"""## üßπ Clean and Extract Relevant Data

To ensure reliable fitting, we remove any rows that have missing values in key columns:

- `zHD`: redshift for the Hubble diagram  
- `MU_SH0ES`: distance modulus  
- `MU_SH0ES_ERR_DIAG`: uncertainty in the distance modulus  

We then extract these cleaned columns as NumPy arrays to prepare for analysis and modeling.

"""

# Drop rows with missing values in the important columns
clean_data = data.dropna(subset=['zHD', 'MU_SH0ES', 'MU_SH0ES_ERR_DIAG'])

# Extract cleaned arrays
z = clean_data['zHD'].values
mu_obs = clean_data['MU_SH0ES'].values
mu_err = clean_data['MU_SH0ES_ERR_DIAG'].values

# Print the first few entries to confirm
print("Cleaned redshift (z):", z[:5])
print("Cleaned distance modulus (mu_obs):", mu_obs[:5])
print("Cleaned uncertainty (mu_err):", mu_err[:5])

"""## üìà Plot the Hubble Diagram

Let‚Äôs visualize the relationship between redshift $z$ and distance modulus $\mu$, known as the Hubble diagram. This plot is a cornerstone of observational cosmology‚Äîit allows us to compare supernova observations with theoretical predictions based on different cosmological models.

We use a logarithmic scale on the redshift axis to clearly display both nearby and distant supernovae.

"""

# Plot the distance modulus vs redshift (Hubble Diagram)

plt.figure(figsize=(8, 6))

# Scatter plot with error bars
plt.errorbar(z, mu_obs, yerr=mu_err, fmt='o', color='black', ecolor='gray',
             elinewidth=0.8, capsize=2, markersize=3, label='Observed SNe Ia')

# Log scale for redshift
plt.xscale('log')

# Axis labels and title
plt.xlabel("Redshift (z)")
plt.ylabel("Distance Modulus (Œº)")
plt.title("Hubble Diagram (Pantheon+SH0ES)")

# Grid and legend
plt.grid(True, which='both', linestyle='--', alpha=0.5)
plt.legend()

plt.tight_layout()
plt.show()

"""## üßÆ Define the Cosmological Model

We now define the theoretical framework based on the flat $\Lambda\mathrm{CDM}$ model (read about the model in wikipedia if needed). This involves:

- The dimensionless Hubble parameter:
  $$
  E(z) = \sqrt{\Omega_m (1+z)^3 + (1 - \Omega_m)}
  $$

- The distance modulus is:
  $$
  \mu(z) = 5 \log_{10}(d_L / \text{Mpc}) + 25
  $$

- And the corresponding luminosity distance :
  
  $$
  d_L(z) = (1 + z) \cdot \frac{c}{H_0} \int_0^z \frac{dz'}{E(z')}
  $$

These equations allow us to compute the expected distance modulus from a given redshift $z$, Hubble constant $H_0$, and matter density parameter $\Omega_m$.

"""

# Speed of light in km/s using astropy constant
c_kms = c.to('km/s').value  # = 299792.458

# E(z): dimensionless Hubble parameter
def E(z, Omega_m):
    return np.sqrt(Omega_m * (1 + z)**3 + (1 - Omega_m))

# Luminosity distance d_L(z) in Mpc
def luminosity_distance(z, H0, Omega_m):
    integral, _ = quad(lambda z_prime: 1 / E(z_prime, Omega_m), 0, z)
    return (c_kms / H0) * (1 + z) * integral

# Distance modulus Œº(z)
def mu_theory(z_array, H0, Omega_m):
    # Handles arrays of redshift for curve_fit
    return np.array([5 * np.log10(luminosity_distance(z, H0, Omega_m)) + 25 for z in z_array])

"""## üîß Fit the Model to Supernova Data

We now perform a non-linear least squares fit to the supernova data using our theoretical model for $\mu(z)$. This fitting procedure will estimate the best-fit values for the Hubble constant $ H_0$ and matter density parameter $\Omega_m$, along with their associated uncertainties.

We'll use:
- `curve_fit` from `scipy.optimize` for the fitting.
- The observed distance modulus \(\mu\), redshift \(z\), and measurement errors.

The initial guess is:
- $ H_0 = 70 \, \text{km/s/Mpc} $
- $\Omega_m =0.3$

"""

from scipy.optimize import curve_fit

# Initial guess for [H0, Omega_m]
p0 = [70, 0.3]

# Fit the model using observed data and measurement errors
params, covariance = curve_fit(mu_theory, z, mu_obs, sigma=mu_err, p0=p0, absolute_sigma=True)

# Extract the fitted parameters and their uncertainties
H0_fit, Omega_m_fit = params
H0_err, Omega_m_err = np.sqrt(np.diag(covariance))

# Print the results
print(f"Fitted H0 = {H0_fit:.2f} ¬± {H0_err:.2f} km/s/Mpc")
print(f"Fitted Omega_m = {Omega_m_fit:.3f} ¬± {Omega_m_err:.3f}")

"""## ‚è≥ Estimate the Age of the Universe

Now that we have the best-fit values of $ H_0 $ and $ \Omega_m $, we can estimate the age of the universe. This is done by integrating the inverse of the Hubble parameter over redshift:

$$
t_0 = \int_0^\infty \frac{1}{(1 + z) H(z)} \, dz
$$

We convert $ H_0 $ to SI units and express the result in gigayears (Gyr). This provides an independent check on our cosmological model by comparing the estimated age to values from other probes like Planck CMB measurements.

"""

from scipy.integrate import quad

def age_of_universe(H0, Omega_m):
    # H0 is in km/s/Mpc ‚Äî convert it to 1/s
    H0_SI = H0 * (1000) / (3.085677581491367e22)  # km/s/Mpc ‚Üí m/s/m ‚Üí 1/s

    # Define the integrand
    def integrand(z):
        return 1 / ((1 + z) * np.sqrt(Omega_m * (1 + z)**3 + (1 - Omega_m)))

    # Integrate from z=0 to ‚àû
    integral, _ = quad(integrand, 0, np.inf)

    # Age in seconds
    age_seconds = integral / H0_SI

    # Convert seconds to gigayears (Gyr)
    age_gyr = age_seconds / (60 * 60 * 24 * 365.25 * 1e9)

    return age_gyr

# Use your fitted parameters
t0 = age_of_universe(H0_fit, Omega_m_fit)
print(f"Estimated age of Universe: {t0:.2f} Gyr")

"""## üìä Analyze Residuals

To evaluate how well our cosmological model fits the data, we compute the residuals:

$$
\text{Residual} = \mu_{\text{obs}} - \mu_{\text{model}}
$$

Plotting these residuals against redshift helps identify any systematic trends, biases, or outliers. A good model fit should show residuals scattered randomly around zero without any significant structure.

"""

# Compute the model predictions using the best-fit parameters
mu_model = mu_theory(z, H0_fit, Omega_m_fit)

# Compute residuals
residuals = mu_obs - mu_model

# Plot the residuals
plt.figure(figsize=(8, 5))
plt.scatter(z, residuals, s=8, color='darkred', alpha=0.7)
plt.axhline(0, color='gray', linestyle='--', linewidth=1)

# Log scale for redshift axis
plt.xscale('log')

# Labels and title
plt.xlabel("Redshift (z)")
plt.ylabel("Residual (Œº_obs - Œº_model)")
plt.title("Residuals of Hubble Diagram Fit")
plt.grid(True, which='both', linestyle='--', alpha=0.4)

plt.tight_layout()
plt.show()

"""## üîß Fit with Fixed Matter Density

To reduce parameter degeneracy, let's fix $ \Omega_m = 0.3 $ and fit only for the Hubble constant $ H_0 $.

"""

# Define the distance modulus function with Omega_m fixed at 0.3
def mu_fixed_Om(z_array, H0):
    return mu_theory(z_array, H0, Omega_m=0.3)
# Now fit only for H0, with Omega_m fixed at 0.3
params_fixed, cov_fixed = curve_fit(mu_fixed_Om, z, mu_obs, sigma=mu_err, p0=[70], absolute_sigma=True)

# Extract result and error
H0_fixed = params_fixed[0]
H0_fixed_err = np.sqrt(np.diag(cov_fixed))[0]

# Print the result
print(f"Fitted H0 with Omega_m fixed at 0.3 = {H0_fixed:.2f} ¬± {H0_fixed_err:.2f} km/s/Mpc")

"""## üîç Compare Low-z and High-z Subsamples

Finally, we examine whether the inferred value of $H_0$ changes with redshift by splitting the dataset into:
- **Low-z** supernovae ($ z < 0.1 $)
- **High-z** supernovae ($ z \geq 0.1 $)

We then fit each subset separately (keeping $ \Omega_m = 0.3 $) to explore any potential tension or trend with redshift.

"""

# Define the split redshift
z_split = 0.1

# Split the data
# Low-z subset (z < 0.1)
z_low = z[z < z_split]
mu_low = mu_obs[z < z_split]
mu_err_low = mu_err[z < z_split]

# High-z subset (z ‚â• 0.1)
z_high = z[z >= z_split]
mu_high = mu_obs[z >= z_split]
mu_err_high = mu_err[z >= z_split]

# Fit H0 for each subset using Omega_m fixed at 0.3

# Fit for low-z
H0_low, cov_low = curve_fit(mu_fixed_Om, z_low, mu_low, sigma=mu_err_low, p0=[70], absolute_sigma=True)

# Fit for high-z
H0_high, cov_high = curve_fit(mu_fixed_Om, z_high, mu_high, sigma=mu_err_high, p0=[70], absolute_sigma=True)

# Print results
print(f"Low-z (z < {z_split}): H‚ÇÄ = {H0_low[0]:.2f} km/s/Mpc")
print(f"High-z (z ‚â• {z_split}): H‚ÇÄ = {H0_high[0]:.2f} km/s/Mpc")

"""You can check your results and potential reasons for different values from accepted constant using this paper by authors of the [Pantheon+ dataset](https://arxiv.org/pdf/2310.11727)

You can find more about the dataset in the paper too
"""